#!/usr/bin/perl
# forcer un upload si changement en local
# ajouter /etc/ocsinventory-agent.conf
# http_proxy configurable
# ports rÃ©seaux
# nmap?

use strict;
use warnings;

use lib 'lib';
use Getopt::Long;

use Ocsinventory::Logger;
use Ocsinventory::Agent::XML::Inventory;
use Ocsinventory::Agent::XML::Prolog;

use Ocsinventory::Agent::Network;
use Ocsinventory::Agent::Backend;
use Ocsinventory::Agent::AccountConfig;
use Ocsinventory::Agent::AccountInfo;
use Ocsinventory::Agent::Pid;
use Ocsinventory::Agent::Config;

use Ocsinventory::Agent::CompatibilityLayer;

our $VERSION = '0.0.6.2';

my $basedir = '';
#$basedir = 'c:/cvs_ocs/ocsinventory-agent';
# default settings;
my $params = { 
  'debug'     =>  0,
  'daemon'    =>  0,
  'force'     =>  0,
  'help'      =>  0,
  'info'      =>  1,
  'local'     =>  '',
  #'logger'    =>  'Syslog,File,Stderr',
  'logger'    =>  'Stderr',
  'logfile'   =>  'ocsinventory-agent.log',
  'password'  =>  '',
  'realm'     =>  '',
  'remotedir' =>  '/ocsinventory',
  'server'    =>  'ocsinventory-ng',
  'stdout'    =>  0,
  'tag'       =>  '',
  'user'      =>  '',
  'wait'      =>  '0',
#  'xml'       =>  0,

  # Other values that can't be changed with the
  # CLI parameters
  'version'   => $VERSION,
  'delaytime' =>  '1', # max delay time (hour)
  'deviceid'  => '',
  'etcdir'    =>  $basedir.'/etc/ocsinventory',
  'basevardir'=>  $basedir.'/var/lib/ocsinventory-agent',
  'logdir'    =>  $basedir.'/var/log/ocsinventory-agent',
  'pidfile'   =>  $basedir.'/var/run/ocsinventory-agent.pid',
};

# Load setting from the config file
my $config = Ocsinventory::Agent::Config::get;
$params->{$_} = $config->{$_} foreach (keys %$config);

$ENV{LC_ALL} = 'C'; # Turn off localised output for commands
$ENV{LANG} = 'C'; # Turn off localised output for commands

my %options = (
  "debug"           =>   \$params->{debug},
  "d|daemon"        =>   \$params->{daemon},
  "f|force"         =>   \$params->{force},
  "h|help"          =>   \$params->{help},
  "i|info"          =>   \$params->{info},
  "l|local=s"       =>   \$params->{local},
  "logfile=s"       =>   \$params->{logfile},
  "p|password=s"    =>   \$params->{password},
  "r|realm=s"       =>   \$params->{realm},
  "R|remotedir=s"   =>   \$params->{remotedir},
  "s|server=s"      =>   \$params->{server},
  "stdout"          =>   \$params->{stdout},
  "t|tag=s"         =>   \$params->{tag},
  "u|user"          =>   \$params->{user},
  "w|wait"          =>   \$params->{wait},
#  "x|xml"           =>   \$params{xml},
#"nosoft"
);
my $pid;

##########################################
##########################################
##########################################
##########################################
sub recMkdir {
  my $dir = shift;

  my @t = split /\//, $dir;
  shift @t;
  return unless @t;

  my $t;
  foreach (@t) {
    $t .= '/'.$_;
    if ((!-d $t) && (!mkdir $t)) {
      return;
    }
  }
  1;
}


sub help {
  my $error = shift;
  if ($error) {
    chomp $error;
    print "ERROR: $error\n\n";
  }

  print STDERR "Setting initialised with values retrieve from the config found at ".$config->{configfile}."\n";

  print STDERR "Usage:\n";
  print STDERR "\t    --debug          debug mode (".$params->{debug}.")\n";
  print STDERR "\t-d  --daemon         detach the agent in background ".
  "and run it silently endlessly (".$params->{daemon}.")\n";
  print STDERR "\t-f --force          always send data to server (Don't ask
  before) ($params->{force})\n";
  print STDERR "\t-i --info           verbose mode (".$params->{info}.")\n";
  print STDERR "\t-l --local=DIR      do not contact server but write ".
  "inventory in DIR directory in XML (".$params->{local}.")\n";
  print STDERR "\t   --logfile=FILE   log message in FILE\n";
  print STDERR "\t-p --password=PWD   password for server auth\n";
  print STDERR "\t-r --realm=REALM    realm for server auth\n";
  print STDERR "\t-s --server=host    server hostname (".$params->{server}.")\n";
  print STDERR "\t   --stdout         do not write or post the inventory but print it on STDOUT\n";
  print STDERR "\t-t --tag=TAG        use TAG as tag (".$params->{tag}."). ".
  "Will be ignored by server if a value already exists.\n";
  print STDERR "\t-u --user=USER      user for server auth\n";
  print STDERR "\t-w --wait           wait during a random periode before".
  "  contacting server like --daemon do (".$params->{wait}.")\n";
#  print STDERR "\t-x --xml            write output in a xml file ($params->{xml})\n";
#  print STDERR "\t--nosoft           do not return installed software list\n";

  exit 1;
}

# TODO
#sub savepid {
#  my $pidfile = shift;
#
#  my $lastpid;
#
#  if (open PIDFILE, "<,$pidfile" ) {
#    my ($lastpid) = <PIDFILE>;
#    print $lastpid;
#  }
#}
#####################################
################ MAIN ###############
#####################################


############################
#### CLI parameters ########
############################
help() if (!GetOptions(%options) || $params->{help});

# I close STDERR to avoid error message during the module execution
# at the begining I was doing shell redirection:
#  my @ret = `cmd 2> /dev/null`;
# but this syntax is not supported on (at least) FreeBSD and Solaris
# c.f: http://www.perlmonks.org/?node_id=571072
my $tmp;
open ($tmp, ">&STDERR");
$params->{"savedstderr"} = $tmp;
if($params->{debug}) {
  $params->{verbose} = 1;
} else {
  close(STDERR);
}

my $logger = new Ocsinventory::Logger ({

    params => $params

  });

############################
#### Objects initilisation 
############################

# The agent can contact different servers. Each server accountconfig is
# stored in a specific file:
if (!recMkdir ($params->{basevardir})) {

  if (! -d $ENV{HOME}."/.ocsinventory/var") {
    $logger->info("Failed to create $params->{basevardir} directory: $!. ".
      "I'm going to use the home directory instead (~/.ocsinventory/var).");
  }

  $params->{basevardir} = $ENV{HOME}."/.ocsinventory/var";
  if (!recMkdir ($params->{basevardir})) {
    $logger->error("Failed to create $params->{basedir} directory: $!".
    "The HOSTID will not be written on the harddrive. You may have duplicated ".
    "entry of this computer in your OCS database");
  }
  $logger->debug("var files are stored in ".$params->{basedir});
}

if (defined($params->{local}) && $params->{local}) {
  $params->{vardir} = $params->{basevardir}."/__LOCAL__";
} else {
  $params->{vardir} = $params->{basevardir}."/".$params->{server};
}
if (!recMkdir ($params->{vardir})) {
  $logger->error("Failed to create $params->{vardir} directory: $!");
}

if (-d $params->{vardir}) {
  $params->{conffile} = $params->{vardir}."/ocsinv.conf";
  $params->{accountinfofile} = $params->{vardir}."/ocsinv.adm";
  $params->{last_statefile} = $params->{vardir}."/last_state";
}
######


# load CFG files
my $accountconfig = new Ocsinventory::Agent::AccountConfig({
    logger => $logger,
    params => $params,
  });

my $srv = $accountconfig->get('OCSFSERVER');
$params->{server} = $srv if $srv;
$params->{deviceid}   = $accountconfig->get('DEVICEID');

# Should I create a new deviceID?
if ((!$params->{deviceid}) || $params->{deviceid} !~ /.*-(?:\d{4})(?:-\d{2}){5}/) {
chomp(my $hostname = `uname -n| cut -d . -f 1`);
  my ($YEAR, $MONTH , $DAY, $HOUR, $MIN, $SEC) = (localtime
    (time))[5,4,3,2,1,0];
  $params->{old_deviceid} = $params->{deviceid};
  $params->{deviceid} =sprintf "%s-%02d-%02d-%02d-%02d-%02d-%02d",
  $hostname, ($YEAR+1900), ($MONTH+1), $DAY, $HOUR, $MIN, $SEC;
  $accountconfig->set('DEVICEID',$params->{deviceid});
  $accountconfig->write();
}

my $accountinfo = new Ocsinventory::Agent::AccountInfo({

    logger => $logger,
    params => $params,

  });

if ($params->{tag}) {
  if ($accountinfo->get("TAG")) {
    $logger->debug("A TAG seems to already exist in the server for this".
      "machine. If so, the -t paramter is usless. Please change the TAG".
      "directly on the server.");
  } else {
    $accountinfo->set("TAG",$params->{tag});
  }
}

my $inventory = new Ocsinventory::Agent::XML::Inventory ({

    accountinfo => $accountinfo,
    logger => $logger,
    params => $params,

  });

my $backend = new Ocsinventory::Agent::Backend ({

    accountinfo => $accountinfo,
    accountconfig => $accountconfig,
    logger => $logger,
    params => $params,

  });

# Create compatibility layer. It's used to keep compatibility with the
# linux_agent 1.x and below
my $compatibilityLayer = new Ocsinventory::Agent::CompatibilityLayer({

    accountinfo => $accountinfo,
    accountconfig => $accountconfig,
    logger => $logger,
    params => $params,

  });

if ($params->{daemon}) {
  
  $logger->debug("Time to call Proc::Daemon");
  require Proc::Daemon;
  Proc::Daemon::Init();
  $logger->debug("Daemon started");
  $pid = new Ocsinventory::Agent::Pid ({
      logger => $logger,
      params => $params,
    });
  
}

$logger->debug("OCS Agent initialised");
#######################################################
#######################################################

do {

  if ($params->{daemon} || $params->{wait}) {
    my $serverdelay = $accountconfig->get('PROLOG_FREQ');
    my $delay = int
    rand(($serverdelay?$serverdelay:$params->{delaytime})*3600);
    $logger->info("Going to sleep for $delay second(s)");
    sleep ($delay);
  }

  $compatibilityLayer->hook({name => 'start_handler'});

# Feed the inventory with its modules
  $backend->feedInventory ({inventory => $inventory});

  if ($params->{stdout}) {
    $inventory->printXML();
  } elsif ($params->{local}) {
    $inventory->writeXML();
  } else { # I've to contact the server
    $inventory->processChecksum();
    my $net = new Ocsinventory::Agent::Network ({

	compatibilityLayer => $compatibilityLayer,
	logger => $logger,
	params => $params,
	respHandlers => {
	  PROLOG_FREQ => sub {$accountconfig->set("PROLOG_FREQ", $_[0])},
	  ACCOUNTINFO => sub {$accountinfo->reSetAll($_[0])},
	}

      });

    my $sendInventory = 1;
    if (!$params->{force}) {
      my $prolog = new Ocsinventory::Agent::XML::Prolog({

	  accountinfo => $accountinfo,
	  logger => $logger,
	  params => $params,

	});

      my $ret = $net->send({message => $prolog});
      $sendInventory = 0 if (!defined($ret) || (defined ($ret) &&
	  $ret->{RESPONSE} !~ /SEND/));
    }

    if ($sendInventory) {

      if (my $ret = $net->send({message => $inventory})) {
        $logger->debug("Server returned: ".$ret->{RESPONSE});
	if ($ret->{RESPONSE} =~ /^ACCOUNT_UPDATE$/) {
	  $inventory->saveLastState();
	}
      }

    } else {
      $logger->info("Don't send the inventory"); 
    }
  }
  $compatibilityLayer->hook({name => 'end_handler'});

} while ($params->{daemon});
