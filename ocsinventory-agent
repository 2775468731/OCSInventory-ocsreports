#!/usr/bin/perl

use strict;
use warnings;

use lib 'lib';
use Getopt::Long;
use Sys::Hostname;

use Ocsinventory::Logger;
use Ocsinventory::Agent::XML::Inventory;
use Ocsinventory::Agent::XML::Prolog;

use Ocsinventory::Agent::Network;
use Ocsinventory::Agent::Backend;
use Ocsinventory::Agent::Config;
use Ocsinventory::Agent::AccountInfo;
use Ocsinventory::Agent::Pid;

use Ocsinventory::Agent::CompatibilityLayer;

our $VERSION = '0.0.2';

my $basedir = '';
#$basedir = 'c:/cvs_ocs/ocsinventory-agent';
# default settings;
my $params = { 
  'debug'     =>  0,
  'daemon'    =>  0,
  'force'     =>  0,
  'help'      =>  0,
  'info'      =>  1,
  'local'     =>  '',
  #'logger'    =>  'Syslog,File,Stderr',
  'logger'    =>  'Stderr',
  'logfile'   =>  'ocsinventory-agent.log',
  'password'  =>  '',
  'realm'     =>  '',
  'remotedir' =>  '/ocsinventory',
  'tag'       =>  '',
  'server'    =>  'ocsinventory-ng',
  'user'      =>  '',
  'wait'      =>  '0',
#  'xml'       =>  0,

  # Other values that can't be changed with the
  # CLI parameters
  'version'   => $VERSION,
  'delaytime' =>  '1', # max delay time (hour)
  'deviceid'  => '',
  'etcdir'    =>  $basedir.'/etc/ocsinventory-agent',
  'basevardir'=>  $basedir.'/var/lib/ocsinventory-agent',
  'logdir'    =>  $basedir.'/var/log/ocsinventory-agent',
  'pidfile'   =>  $basedir.'/var/run/ocsinventory-agent.pid',
};

$ENV{LC_ALL} = 'C'; # Turn off localised output for commands
$ENV{LANG} = 'C'; # Turn off localised output for commands

my %options = (
  "debug"           =>   \$params->{debug},
  "d|daemon"        =>   \$params->{daemon},
  "f|force"         =>   \$params->{force},
  "h|help"          =>   \$params->{help},
  "i|info"          =>   \$params->{info},
  "l|local=s"       =>   \$params->{local},
  "logfile=s"       =>   \$params->{logfile},
  "p|password=s"    =>   \$params->{password},
  "r|realm=s"       =>   \$params->{realm},
  "R|remotedir=s"   =>   \$params->{remotedir},
  "t|tag=s"         =>   \$params->{tag},
  "s|server=s"      =>   \$params->{server},
  "u|user"          =>   \$params->{user},
  "w|wait"          =>   \$params->{wait},
#  "x|xml"           =>   \$params{xml},
#"nosoft"
);
my $pid;

##########################################
##########################################
##########################################
##########################################
sub help {
  my $error = shift;
  if ($error) {
    chomp $error;
    print "ERROR: $error\n\n";
  }

  print STDERR "Usage:\n";
  print STDERR "\t    --debug          debug mode ($params->{debug})\n";
  print STDERR "\t-d  --daemon         detach the agent in background ".
  "and run it silently endlessly ($params->{daemon})\n";
  print STDERR "\t-f --force          always send data to server (Don't ask
  before) ($params->{force})\n";
  print STDERR "\t-i --info           verbose mode ($params->{info})\n";
  print STDERR "\t-l --local=DIR      do not contact server but write ".
  "inventory in DIR directory in XML ($params->{local})\n";
  print STDERR "\t   --logfile=FILE   log message in FILE\n";
  print STDERR "\t-p --password=PWD   password for server auth\n";
  print STDERR "\t-r --realm=REALM    realm for server auth\n";
  print STDERR "\t-s --server=URI     URI to the server place ".
  "($params->{server})\n";
  print STDERR "\t-t --tag=TAG        use TAG as tag ($params->{tag}). ".
  "Will be ignored by server if a value already exists.\n";
  print STDERR "\t-u --user=USER      user for server auth\n";
  print STDERR "\t-w --wait           wait during a random periode before".
  "  contacting server like --daemon do ($params->{wait})\n";
#  print STDERR "\t-x --xml            write output in a xml file ($params->{xml})\n";
#  print STDERR "\t--nosoft           do not return installed software list\n";

  exit 1;
}

# TODO
#sub savepid {
#  my $pidfile = shift;
#
#  my $lastpid;
#
#  if (open PIDFILE, "<,$pidfile" ) {
#    my ($lastpid) = <PIDFILE>;
#    print $lastpid;
#  }
#}
#####################################
################ MAIN ###############
#####################################


############################
#### CLI parameters ########
############################
help() if (!GetOptions(%options) || $params->{help});

my $logger = new Ocsinventory::Logger ({

    params => $params

  });

############################
#### Objects initilisation 
############################

# The agent can contact different servers. Every server config are
# stored in a specific file:
if (defined($params->{local}) && $params->{local}) {
  $params->{vardir} = $params->{basevardir}."/__LOCAL__";
} else {
  $params->{vardir} = $params->{basevardir}."/".$params->{server};
}
if (!-d $params->{vardir} && !mkdir ($params->{vardir})) {
  $logger->error("Failed to create $params->{vardir} directory: $!");
}


$params->{conffile} = $params->{vardir}."/ocsinv.conf";
$params->{accountinfofile} = $params->{vardir}."/ocsinv.adm";
$params->{laste_statfile} = $params->{vardir}."/last_stat";
######


# load CFG files
my $config = new Ocsinventory::Agent::Config({
    logger => $logger,
    params => $params,
  });

my $srv = $config->get('OCSFSERVER');
$params->{server} = $srv if $srv;
$params->{deviceid}   = $config->get('DEVICEID');

# Should I create a new deviceID?
#chomp(my $tmp = `uname -n| cut -d . -f 1`);
if ((!$params->{deviceid}) || $params->{deviceid} !~ /.*-(?:\d{4})(?:-\d{2}){5}/) {
  my ($YEAR, $MONTH , $DAY, $HOUR, $MIN, $SEC) = (localtime
    (time))[5,4,3,2,1,0];
  $params->{old_deviceid} = $params->{deviceid};
  $params->{deviceid} =sprintf "%s-%02d-%02d-%02d-%02d-%02d-%02d",
  hostname, ($YEAR+1900), ($MONTH+1), $DAY, $HOUR, $MIN, $SEC;
  $config->set('DEVICEID',$params->{deviceid});
}

my $accountinfo = new Ocsinventory::Agent::AccountInfo({

    logger => $logger,
    params => $params,

  });

if ($params->{tag}) {
  if ($accountinfo->get("TAG")) {
    $logger->debug("A TAG seems to already exist in the server for this".
      "machine. If so, the -t paramter is usless. Please change the TAG".
      "directly on the server.");
  } else {
    $accountinfo->set("TAG",$params->{tag});
  }
}

my $inventory = new Ocsinventory::Agent::XML::Inventory ({

    accountinfo => $accountinfo,
    logger => $logger,
    params => $params,

  });

my $backend = new Ocsinventory::Agent::Backend ({

    accountinfo => $accountinfo,
    config => $config,
    logger => $logger,
    params => $params,

  });

# Create compatibility layer. It's used to keep compatibility with the
# linux_agent 1.x and bellow
my $compatibilityLayer = new Ocsinventory::Agent::CompatibilityLayer({

    accountinfo => $accountinfo,
    config => $config,
    logger => $logger,
    params => $params,

  });

if ($params->{daemon}) {
  
  $logger->debug("Time to call Proc::Daemon");
  require Proc::Daemon;
  Proc::Daemon::Init();
  $logger->debug("Daemon started");
  $pid = new Ocsinventory::Agent::Pid ({
      logger => $logger,
      params => $params,
    });
  $logger->debug("Yo!");
  
}

$logger->info("OCS Agent initialised");
#######################################################
#######################################################

do {

  if ($params->{daemon} || $params->{wait}) {
    my $serverdelay = $config->get('PROLOG_FREQ');
    my $delay = int
    rand(($serverdelay?$serverdelay:$params->{delaytime})*3600);
    $logger->info("Going to sleep for $delay second(s)");
    sleep ($delay);
  }

  $compatibilityLayer->hook({name => 'start_handler'});

# Feed the inventory with its modules
  $backend->feedInventory ({inventory => $inventory});

  if ($params->{local}) {
    $inventory->writeXML();
  } else { # I've to contact the server
    my $net = new Ocsinventory::Agent::Network ({

	compatibilityLayer => $compatibilityLayer,
	logger => $logger,
	params => $params,
	respHandlers => {
	  PROLOG_FREQ => sub {$config->set("PROLOG_FREQ", $_[0])},
	  ACCOUNTINFO => sub {$accountinfo->reSetAll($_[0])},
	}

      });

    my $sendIventory = 1;
    if (!$params->{force}) {
      my $prolog = new Ocsinventory::Agent::XML::Prolog({

	  accountinfo => $accountinfo,
	  logger => $logger,
	  params => $params,

	});

      my $ret = $net->send({message => $prolog});
      $sendIventory = 0 if (!defined($ret) || (defined ($ret) &&
	  $ret->{RESPONSE} !~ /SEND/));
    }

    if ($sendIventory) {

      if (my $ret = $net->send({message => $inventory})) {
	$logger->debug("Server returned: ".$ret->{RESPONSE});
      }

    } else {
      $logger->info('No need to send the inventory'); 
    }
  }
  $compatibilityLayer->hook({name => 'end_handler'});

} while ($params->{daemon});
